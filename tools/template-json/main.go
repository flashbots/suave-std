package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	"text/template/parse"

	"github.com/BurntSushi/toml"
	"github.com/umbracle/ethgo/abi"
)

type Config struct {
	ContractName string                 `toml:"contract_name"`
	Structs      map[string]structDef   `toml:"structs"`
	Funcs        map[string]functionDef `toml:"functions"`
}

type structDef struct {
	Type string `toml:"type"`
}

type functionDef struct {
	Template string   `toml:"template"`
	Inputs   []string `toml:"inputs"`
}

var (
	outputPathFlag string
	formatFlag     bool
)

func main() {
	flag.StringVar(&outputPathFlag, "output", "", "output path")
	flag.BoolVar(&formatFlag, "format", false, "whether to format the output")
	flag.Parse()

	if outputPathFlag != "" {
		// always format if we write to file
		formatFlag = true
	}

	args := flag.Args()
	if len(args) != 1 {
		panic("usage: <config.toml>")
	}

	tomlData, err := os.ReadFile(args[0])
	if err != nil {
		panic(err)
	}

	var conf Config
	if _, err := toml.Decode(string(tomlData), &conf); err != nil {
		panic(err)
	}

	s := state{
		config: &conf,
	}

	// process first all the types
	for name, def := range conf.Structs {
		typ := abi.MustNewType(def.Type)
		s.encodeStruct(name, typ)
	}

	// encode the functions
	for name, fn := range conf.Funcs {
		// build a new tuple type that encompases all the arguments
		allTypes := []string{}

		for indx, name := range fn.Inputs {
			obj := conf.Structs[name].Type
			allTypes = append(allTypes, obj+" "+fmt.Sprintf("obj%d", indx))
		}

		argType := "tuple(" + strings.Join(allTypes, ",") + ")"
		s.Encode(name, fn.Inputs, argType, fn.Template)
	}

	str := s.Render()
	if formatFlag {
		var err error
		if str, err = formatSolidity(str); err != nil {
			panic(err)
		}
	}
	if outputPathFlag != "" {
		if err := writeFile(outputPathFlag, []byte(str)); err != nil {
			panic(err)
		}
	} else {
		fmt.Println(str)
	}
}

type state struct {
	config  *Config
	Structs []string
	Funcs   []string
}

var encodeContractTemplate = `// SPDX-License-Identifier: UNLICENSED
// DO NOT edit this file. Code generated by forge-gen.
pragma solidity ^0.8.8;

import "solady/src/utils/LibString.sol";

library {{.ContractName}} {
	{{range .Structs}}
	{{.}}
	{{end}}

	{{range .Funcs}}
	{{.}}
	{{end}}
}`

func (s *state) Render() string {
	t, err := template.New("template").Parse(encodeContractTemplate)
	if err != nil {
		panic(err)
	}

	inputs := map[string]interface{}{
		"ContractName": s.config.ContractName,
		"Structs":      s.Structs,
		"Funcs":        s.Funcs,
	}

	var outputRaw bytes.Buffer
	if err = t.Execute(&outputRaw, inputs); err != nil {
		panic(err)
	}

	str := outputRaw.String()
	return str
}

func (s *state) Encode(funcName string, structName []string, typStr, template string) {
	t, err := abi.NewType(typStr)
	if err != nil {
		panic(err)
	}

	encodeFunc := encodeFuncState{
		funcName: funcName,
	}
	encodeFunc.Walk(structName, t, template)

	s.Funcs = append(s.Funcs, encodeFunc.result())
}

var funcMap = template.FuncMap{
	"toHexString": func(typ *refType) string {
		return "LibString.toHexString(" + typ.name + ")"
	},
	"toString": func(typ *refType) string {
		return "LibString.toString(" + typ.name + ")"
	},
}

type encodeFuncState struct {
	funcName string
	res      []*blob
}

type blob struct {
	encodes []string
	stmt    string
}

func (b *blob) isStmt() bool {
	return b.stmt != ""
}

func (s *encodeFuncState) result() string {
	res := []string{}

	//render the string, each statement in a separated line
	for _, b := range s.res {
		if b.isStmt() {
			res = append(res, b.stmt)
		} else {
			res = append(res, "body = abi.encodePacked(body, "+strings.Join(b.encodes, ",")+");")
		}
	}

	return strings.Join(res, "\n")
}

func (s *encodeFuncState) addBlob(str string) {
	// merge blob in the previous entry if not an statement
	createEntry := true
	size := len(s.res)
	if size > 0 && !s.res[size-1].isStmt() {
		createEntry = false
	}
	if createEntry {
		s.res = append(s.res, &blob{
			encodes: []string{str},
		})
	} else {
		blob := s.res[size-1]
		blob.encodes = append(blob.encodes, str)
	}
}

func (s *encodeFuncState) addStmt(str string) {
	s.res = append(s.res, &blob{stmt: str})
}

func fullTrimString(str string) string {
	str = strings.TrimSpace(str)
	str = strings.ReplaceAll(str, "\n", "")
	str = strings.ReplaceAll(str, "\t", "")
	str = strings.ReplaceAll(str, "\r", "")
	return str
}

func (s *encodeFuncState) Walk(structName []string, typ *abi.Type, templateStr string) string {
	trees, err := parse.Parse("name", templateStr, "", "", funcMap)
	if err != nil {
		panic(err)
	}
	node := trees["name"].Root

	args := []string{}
	for indx, name := range structName {
		args = append(args, fmt.Sprintf("%s memory obj%d", name, indx))
	}

	// creation of the function
	s.addStmt(`function ` + s.funcName + `(` + strings.Join(args, ", ") + `) internal pure returns (bytes memory) {`)
	s.addStmt(`bytes memory body;`)

	// body
	s.walk(&refType{Type: typ, name: ""}, node)

	// end of the function
	s.addStmt(`return body;`)
	s.addStmt(`}`)

	return s.result()
}

// Walk functions step through the major pieces of the template structure,
// generating output as they go.
func (s *encodeFuncState) walk(typ *refType, node parse.Node) {
	switch node := node.(type) {
	case *parse.ActionNode:
		// something like {{.name}} in the template
		val := s.evalCommand(typ, node.Pipe.Cmds[0])

		s.addBlob(val.name)

	case *parse.IfNode:
		s.walkIfOrWith(typ, node.Pipe, node.List, node.ElseList)

	case *parse.ListNode:
		for _, node := range node.Nodes {
			s.walk(typ, node)
		}

	case *parse.RangeNode:
		s.walkRange(typ, node)

	case *parse.TextNode:
		txt := fullTrimString(string(node.Text))
		if txt == "" {
			return
		}
		s.addBlob("'" + txt + "'")

	case *parse.BreakNode:
		panic("break statements not supported")

	case *parse.CommentNode:
		panic("comment blocks not supported")

	case *parse.ContinueNode:
		panic("continue statements not supported")

	case *parse.TemplateNode:
		panic("templates not supported")

	case *parse.WithNode:
		panic("with statements not supported")

	default:
		panic(fmt.Sprintf("unknown node: %T", node))
	}
}

func (s *encodeFuncState) walkRange(typ *refType, r *parse.RangeNode) {
	// write range statement
	item := s.evalCommand(typ, r.Pipe.Cmds[0])
	// item must be an array to work on a range
	if item.Kind() != abi.KindSlice {
		panic("not an array")
	}

	s.addStmt(`for (uint64 i=0; i<` + item.name + `.length; i++) {`)

	// loop over the items
	s.walk(&refType{Type: item.Type, name: item.name + "[i]"}, r.List)

	// add , if not the last item
	s.addStmt(`if (i < ` + item.name + `.length-1) {`)
	s.addBlob("','")
	s.addStmt(`}`)

	s.addStmt(`}`)
}

func (s *encodeFuncState) walkIfOrWith(typ *refType, pipe *parse.PipeNode, list, elseList *parse.ListNode) {
	// write condition
	ref := s.evalCommand(typ, pipe.Cmds[0])
	s.addStmt(`if (` + ref.name + ` != 0) {`)

	// write body of the if statement
	s.walk(typ, list)

	if elseList == nil {
		// no if statement, just close the if
		s.addStmt(`}`)
	} else {
		// write else if statement (if any)
		s.addStmt(`} else {`)
		s.walk(typ, elseList)
		s.addStmt(`}`)
	}
}

func mergeNames(a, b string) string {
	if a == "" {
		return b
	}
	return a + "." + b
}

func (s *encodeFuncState) evalCommand(typ *refType, cmd *parse.CommandNode) *refType {
	firstWord := cmd.Args[0]
	switch obj := firstWord.(type) {
	case *parse.FieldNode:
		for _, iden := range obj.Ident {
			// search the identifier in the struct, it must be a tuple
			if typ.Type.Kind() != abi.KindTuple {
				panic("not a tuple")
			}

			found := false
			for _, elem := range typ.TupleElems() {
				if elem.Name == iden {
					typ = &refType{Type: elem.Elem, name: mergeNames(typ.name, elem.Name)}
					found = true
					break
				}
			}
			if !found {
				panic(fmt.Sprintf("field %s not found in %s", iden, typ.name))
			}
		}
		return typ

	case *parse.DotNode:
		return typ

	case *parse.IdentifierNode:
		// Right now it only encodes functions that convert a type into its string representation
		fn, ok := funcMap[obj.Ident]
		if !ok {
			panic(fmt.Sprintf("function %s not found", obj.Ident))
		}

		fmt.Println("-- typ --")
		fmt.Println(cmd.Args)
		fmt.Println(typ)
		fmt.Println(obj.Ident)

		eFn := fn.(func(typ *refType) string)
		return &refType{name: eFn(typ)}

	default:
		panic(fmt.Sprintf("unknown eval command type: %T", obj))
	}
}

// refType is a type that is referenced by name.
type refType struct {
	name string
	*abi.Type
}

func (s *state) encodeStruct(name string, t *abi.Type) string {
	switch t.Kind() {
	case abi.KindTuple:
		attrs := []string{}
		for _, i := range t.TupleElems() {
			attrs = append(attrs, fmt.Sprintf("%s %s;", s.encodeStruct(i.Name, i.Elem), i.Name))
		}
		structName := strings.Title(name)

		str := fmt.Sprintf("struct %s {\n%s\n}\n", structName, strings.Join(attrs, "\n"))
		s.Structs = append(s.Structs, str)

		return structName

	case abi.KindSlice:
		return fmt.Sprintf("%s[]", s.encodeStruct(name, t.Elem()))

	case abi.KindArray:
		return fmt.Sprintf("%s[%d]", s.encodeStruct(name, t.Elem()), t.Size())

	default:
		return t.String()
	}
}

func formatSolidity(code string) (string, error) {
	return execForgeCommand([]string{"fmt", "--raw", "-"}, code)
}

func execForgeCommand(args []string, stdin string) (string, error) {
	_, err := exec.LookPath("forge")
	if err != nil {
		return "", fmt.Errorf("forge command not found in PATH: %v", err)
	}

	// Create a command to run the forge command
	cmd := exec.Command("forge", args...)

	// Set up input from stdin
	if stdin != "" {
		cmd.Stdin = bytes.NewBufferString(stdin)
	}

	// Set up output buffer
	var outBuf, errBuf bytes.Buffer
	cmd.Stdout = &outBuf
	cmd.Stderr = &errBuf

	// Run the command
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("error running command: %v, %s", err, errBuf.String())
	}

	return outBuf.String(), nil
}

// writeFile creates the parent directory if not found
// and then writes the file to the path.
func writeFile(path string, content []byte) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	if err := os.WriteFile(path, content, 0644); err != nil {
		return err
	}
	return nil
}
